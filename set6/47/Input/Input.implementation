size_t ScannerBase::Input::lineNr() const
{
  return d_lineNr;
}

size_t ScannerBase::Input::nPending() const
{
  return d_deque.size();
}

void ScannerBase::Input::setPending(size_t size)
{
  d_deque.erase(d_deque.begin(), d_deque.end() - size);
}

void ScannerBase::Input::close()                    // force closing the stream
{
  delete d_in;
  d_in = 0;                   // switchStreams also closes
}

ScannerBase::Input::Input()
  :
  d_in(0),
  d_lineNr(1)
{}

ScannerBase::Input::Input(std::istream *iStream, size_t lineNr)
  :
  d_in(iStream),
  d_lineNr(lineNr)
{}

size_t ScannerBase::Input::get()
{
  ++d_offset;
  switch (size_t ch = next())         // get the next input char
  {
    case '\n':
      ++d_lineNr;
      [[fallthrough]];

    default:
      return ch;
  }
}

size_t ScannerBase::Input::next()
{
  size_t ch;

  if (d_deque.empty())                // deque empty: next char fm d_in
  {
    if (d_in == 0)
      return AT_EOF;
    ch = d_in->get();
    return *d_in ? ch : static_cast<size_t>(AT_EOF);
  }

  ch = d_deque.front();
  d_deque.pop_front();

  return ch;
}

void ScannerBase::Input::reRead(size_t ch)
{
  --d_offset;
  if (ch < 0x100)
  {
    if (ch == '\n')
      --d_lineNr;
    d_deque.push_front(ch);
  }
}

void ScannerBase::Input::reRead(std::string const &str, size_t fm)
{
  for (size_t idx = str.size(); idx-- > fm; )
    reRead(str[idx]);
}

size_t ScannerBase::Input::lineOffset() const
{
  return d_offset;
}
