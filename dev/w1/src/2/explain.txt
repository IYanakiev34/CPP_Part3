In order to bend the rules the way the
exercise wants we need a few things:
1. The type that we will pass to the function
to cast to another type
2. The target type that we wish to cast
3. The function needs to be inline in order
not to produce function call.

Thus we end up with the following skeleton:

template <typename S, typename T>
inline T as(S &&source)
{
    return static_cast<T>(source);
}

We pass a universal reference since this would allow
us to pass all the types needed to a function. This
also allows us to do any of the conversions either
explicit or implicit such as pointer to array etc.
